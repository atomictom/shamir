use crate::encoder::RSEncoder;
use crate::encoder::RSStream;
use crate::encoder::VandermondeEncoder;
use crate::encoding::Encoding;
use crate::finite_field::ExpLogField;
use crate::words;
use rand::Rng;
use std::iter;

const WORDLIST_PATH: &'static str = "./assets/wordlist256.txt";

fn gen_random_bytes(length: usize) -> Vec<u8> {
    let mut rng = rand::thread_rng();
    return (0..length).map(|_| rng.gen()).collect();
}

pub fn shamir(shards: usize, required: usize, length: usize) -> Vec<String> {
    assert!(shards >= required);
    println!("Shards: {}, required: {}", shards, required);
    let wordlist = words::load_word_list(WORDLIST_PATH);

    let encoding = Encoding {
        data_chunks: required as u8,
        code_chunks: (shards - required) as u8,
    };
    let encoder = VandermondeEncoder::default();
    let field = ExpLogField::default();

    let mut phrases: Vec<Vec<&str>> = (0..shards).map(|_| Vec::with_capacity(length)).collect();

    // The first word is the index of the shard.
    for i in 1..phrases.len() {
        phrases[i].push(&wordlist[i]);
    }

    // Remaining words are generated through repeated RS rounds.
    for _ in 0..length {
        // Generate a vector of random bytes to generate the RS round with.
        let bytes = gen_random_bytes(required);
        // Encode the random bytes to get a stream of both the input bytes and additional
        // generated bytes.
        let stream = encoder
            .encode_bytes(encoding, &field, &bytes[..])
            .expect(&format!(
                "Encoding did not work for byte stream: {:?}",
                &bytes
            ));
        // Because we only had "required" bytes, there was only one stripe of codes, so the output
        // will be in "codes[0]".
        for (i, byte) in stream.codes[0].iter().enumerate() {
            phrases[i].push(&wordlist[*byte as usize]);
        }
    }

    let strings: Vec<String> = phrases.into_iter().map(|words| words.join(" ")).collect();
    return strings;
}

// Note that phrases is positional
pub fn unshamir(phrases: &Vec<String>, required: usize, total: usize) -> String {
    // Map the words back to u8s
    let wordlist: Vec<String> = words::load_word_list(WORDLIST_PATH);
    let wordmap = words::words_map(&wordlist[..]);
    let words: Vec<Vec<u8>> = phrases
        .into_iter()
        .map(|phrase| words::from_words(phrase.trim().split(" "), &wordmap))
        .collect();

    // We'll use the indices to find which shards we have.
    let mut present: Vec<Option<Vec<u8>>> = iter::repeat(None).take(total).collect();
    let mut valid: Vec<bool> = iter::repeat(false).take(total).collect();
    for phrase in words.iter() {
        assert!(phrase.len() > 0);
        let index = phrase[0] as usize;
        assert!(index < total);
        valid[index] = true;
        present[index] = Some(phrase.clone());
    }
    println!("Valid: {:?}", valid);

    // Ensure the length of the phrases is uniform. This minus one (the first word is just the
    // index) is how many RS rounds we have to do.
    let length: usize = words.iter().map(|x| x.len()).max().unwrap_or(0);
    println!("Length: {}", length);
    assert!(words.iter().all(|x| x.len() == 0 || x.len() == length));

    // Skip the first word in each phrase.
    let codes: Vec<Vec<u8>> = (1..length)
        .map(|i| {
            (0..present.len())
                .map(|j| match present[j] {
                    None => 0,
                    Some(_) => present[j].as_ref().unwrap()[i],
                })
                .collect()
        })
        .collect();
    let encoding = Encoding {
        data_chunks: required as u8,
        code_chunks: (total - required) as u8,
    };
    println!("Encoding: {:?}", encoding);
    let encoder = VandermondeEncoder::default();
    let field = ExpLogField::default();

    let mut password_words: Vec<&str> = Vec::with_capacity(length);
    for chunk in codes {
        let stream = RSStream {
            length: required,
            encoding: encoding,
            codes: vec![chunk],
            valid: valid.clone(),
        };
        match encoder.decode_bytes(&stream, &field) {
            Ok(data) => password_words.push(&wordlist[data[0] as usize]),
            Err(e) => panic!("Got an error {} while decoding.", e),
        };
    }
    let password = password_words.join(" ");
    println!("Shards: {}, required: {}", phrases.len(), required);
    println!("Password: {}", password);
    return password;
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn shamir_unshamir() {
        let phrases = shamir(6, 3, 10);
        assert_eq!(
            unshamir(
                &vec![phrases[1].clone(), phrases[3].clone(), phrases[5].clone(),],
                3,
                6,
            ),
            phrases[0]
        );
    }

    #[test]
    fn test_unshamir() {
        assert_eq!(
            unshamir(
                &vec![
                    "affix spill lens showy quota baggy tart start affix spew path".to_string(),
                    "ajar agony shove draw fried vest grid hump date urban card".to_string(),
                    "angle neon from silk stud aqua opal ajar aqua shove dingy".to_string(),
                ],
                3,
                6,
            ),
            "ozone puma shirt shy swab stunt trade july sharp dusk"
        );
    }
}
